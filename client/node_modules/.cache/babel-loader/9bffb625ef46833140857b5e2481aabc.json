{"ast":null,"code":"'use strict';\n\nconst convert = require('./convert');\n\nconst protocols = require('./protocols-table');\n\nconst varint = require('varint');\n\nconst _require = require('uint8arrays/concat'),\n      uint8ArrayConcat = _require.concat;\n\nconst _require2 = require('uint8arrays/to-string'),\n      uint8ArrayToString = _require2.toString; // export codec\n\n\nmodule.exports = {\n  stringToStringTuples,\n  stringTuplesToString,\n  tuplesToStringTuples,\n  stringTuplesToTuples,\n  bytesToTuples,\n  tuplesToBytes,\n  bytesToString,\n  stringToBytes,\n  fromString,\n  fromBytes,\n  validateBytes,\n  isValidBytes,\n  cleanPath,\n  ParseError,\n  protoFromTuple,\n  sizeForAddr\n}; // string -> [[str name, str addr]... ]\n\n/**\r\n * @param {string} str\r\n */\n\nfunction stringToStringTuples(str) {\n  const tuples = [];\n  const parts = str.split('/').slice(1); // skip first empty elem\n\n  if (parts.length === 1 && parts[0] === '') {\n    return [];\n  }\n\n  for (let p = 0; p < parts.length; p++) {\n    const part = parts[p];\n    const proto = protocols(part);\n\n    if (proto.size === 0) {\n      tuples.push([part]);\n      continue;\n    }\n\n    p++; // advance addr part\n\n    if (p >= parts.length) {\n      throw ParseError('invalid address: ' + str);\n    } // if it's a path proto, take the rest\n\n\n    if (proto.path) {\n      tuples.push([part, // TODO: should we need to check each path part to see if it's a proto?\n      // This would allow for other protocols to be added after a unix path,\n      // however it would have issues if the path had a protocol name in the path\n      cleanPath(parts.slice(p).join('/'))]);\n      break;\n    }\n\n    tuples.push([part, parts[p]]);\n  }\n\n  return tuples;\n} // [[str name, str addr]... ] -> string\n\n/**\r\n * @param {[number, string?][]} tuples\r\n */\n\n\nfunction stringTuplesToString(tuples) {\n  /** @type {Array<string | undefined>} */\n  const parts = [];\n  tuples.map(tup => {\n    const proto = protoFromTuple(tup);\n    parts.push(proto.name);\n\n    if (tup.length > 1) {\n      parts.push(tup[1]);\n    }\n\n    return null;\n  });\n  return cleanPath(parts.join('/'));\n} // [[str name, str addr]... ] -> [[int code, Uint8Array]... ]\n\n/**\r\n * @param {Array<string[] | string >} tuples\r\n * @returns {[number , Uint8Array?][]}\r\n */\n\n\nfunction stringTuplesToTuples(tuples) {\n  return tuples.map(tup => {\n    if (!Array.isArray(tup)) {\n      tup = [tup];\n    }\n\n    const proto = protoFromTuple(tup);\n\n    if (tup.length > 1) {\n      return [proto.code, convert.toBytes(proto.code, tup[1])];\n    }\n\n    return [proto.code];\n  });\n}\n/**\r\n * Convert tuples to string tuples\r\n *\r\n * [[int code, Uint8Array]... ] -> [[int code, str addr]... ]\r\n *\r\n * @param {Array<[number, Uint8Array?]>} tuples\r\n * @returns {Array<[number, string?]>}\r\n */\n\n\nfunction tuplesToStringTuples(tuples) {\n  return tuples.map(tup => {\n    const proto = protoFromTuple(tup);\n\n    if (tup[1]) {\n      return [proto.code, convert.toString(proto.code, tup[1])];\n    }\n\n    return [proto.code];\n  });\n} // [[int code, Uint8Array ]... ] -> Uint8Array\n\n/**\r\n * @param {[number, Uint8Array?][]} tuples\r\n */\n\n\nfunction tuplesToBytes(tuples) {\n  return fromBytes(uint8ArrayConcat(tuples.map(\n  /** @type {any[]} */\n  tup => {\n    const proto = protoFromTuple(tup);\n    let buf = Uint8Array.from(varint.encode(proto.code));\n\n    if (tup.length > 1) {\n      buf = uint8ArrayConcat([buf, tup[1]]); // add address buffer\n    }\n\n    return buf;\n  })));\n}\n/**\r\n * @param {import(\"./types\").Protocol} p\r\n * @param {Uint8Array | number[]} addr\r\n */\n\n\nfunction sizeForAddr(p, addr) {\n  if (p.size > 0) {\n    return p.size / 8;\n  } else if (p.size === 0) {\n    return 0;\n  } else {\n    const size = varint.decode(addr);\n    return size + varint.decode.bytes;\n  }\n}\n/**\r\n *\r\n * @param {Uint8Array} buf\r\n * @returns {Array<[number, Uint8Array?]>}\r\n */\n\n\nfunction bytesToTuples(buf) {\n  /** @type {Array<[number, Uint8Array?]>} */\n  const tuples = [];\n  let i = 0;\n\n  while (i < buf.length) {\n    const code = varint.decode(buf, i);\n    const n = varint.decode.bytes;\n    const p = protocols(code);\n    const size = sizeForAddr(p, buf.slice(i + n));\n\n    if (size === 0) {\n      tuples.push([code]);\n      i += n;\n      continue;\n    }\n\n    const addr = buf.slice(i + n, i + n + size);\n    i += size + n;\n\n    if (i > buf.length) {\n      // did not end _exactly_ at buffer.length\n      throw ParseError('Invalid address Uint8Array: ' + uint8ArrayToString(buf, 'base16'));\n    } // ok, tuple seems good.\n\n\n    tuples.push([code, addr]);\n  }\n\n  return tuples;\n} // Uint8Array -> String\n\n/**\r\n * @param {Uint8Array} buf\r\n */\n\n\nfunction bytesToString(buf) {\n  const a = bytesToTuples(buf);\n  const b = tuplesToStringTuples(a);\n  return stringTuplesToString(b);\n} // String -> Uint8Array\n\n/**\r\n * @param {string} str\r\n */\n\n\nfunction stringToBytes(str) {\n  str = cleanPath(str);\n  const a = stringToStringTuples(str);\n  const b = stringTuplesToTuples(a);\n  return tuplesToBytes(b);\n} // String -> Uint8Array\n\n/**\r\n * @param {string} str\r\n */\n\n\nfunction fromString(str) {\n  return stringToBytes(str);\n} // Uint8Array -> Uint8Array\n\n/**\r\n * @param {Uint8Array} buf\r\n */\n\n\nfunction fromBytes(buf) {\n  const err = validateBytes(buf);\n  if (err) throw err;\n  return Uint8Array.from(buf); // copy\n}\n/**\r\n * @param {Uint8Array} buf\r\n */\n\n\nfunction validateBytes(buf) {\n  try {\n    bytesToTuples(buf); // try to parse. will throw if breaks\n  } catch (err) {\n    return err;\n  }\n}\n/**\r\n * @param {Uint8Array} buf\r\n */\n\n\nfunction isValidBytes(buf) {\n  return validateBytes(buf) === undefined;\n}\n/**\r\n * @param {string} str\r\n */\n\n\nfunction cleanPath(str) {\n  return '/' + str.trim().split('/').filter(\n  /** @type {any} */\n  a => a).join('/');\n}\n/**\r\n * @param {string} str\r\n */\n\n\nfunction ParseError(str) {\n  return new Error('Error parsing address: ' + str);\n}\n/**\r\n * @param {any[]} tup\r\n */\n\n\nfunction protoFromTuple(tup) {\n  const proto = protocols(tup[0]);\n  return proto;\n}","map":null,"metadata":{},"sourceType":"script"}