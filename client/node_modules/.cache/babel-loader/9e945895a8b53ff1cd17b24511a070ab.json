{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar multiformats = require('multiformats');\n\nvar base64 = require('multiformats/bases/base64');\n\nvar cborg = require('cborg');\n\nvar cborgJson = require('cborg/json');\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar cborgJson__namespace =\n/*#__PURE__*/\n_interopNamespace(cborgJson);\n\nfunction cidEncoder(obj) {\n  if (obj.asCID !== obj) {\n    return null;\n  }\n\n  const cid = multiformats.CID.asCID(obj);\n\n  if (!cid) {\n    return null;\n  }\n\n  const cidString = cid.toString();\n  return [new cborg.Token(cborg.Type.map, Infinity, 1), new cborg.Token(cborg.Type.string, '/', 1), new cborg.Token(cborg.Type.string, cidString, cidString.length), new cborg.Token(cborg.Type.break, undefined, 1)];\n}\n\nfunction bytesEncoder(bytes) {\n  const bytesString = base64.base64.encode(bytes).slice(1);\n  return [new cborg.Token(cborg.Type.map, Infinity, 1), new cborg.Token(cborg.Type.string, '/', 1), new cborg.Token(cborg.Type.map, Infinity, 1), new cborg.Token(cborg.Type.string, 'bytes', 5), new cborg.Token(cborg.Type.string, bytesString, bytesString.length), new cborg.Token(cborg.Type.break, undefined, 1), new cborg.Token(cborg.Type.break, undefined, 1)];\n}\n\nfunction undefinedEncoder() {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');\n}\n\nfunction numberEncoder(num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n\n  return null;\n}\n\nconst encodeOptions = {\n  typeEncoders: {\n    Object: cidEncoder,\n    Uint8Array: bytesEncoder,\n    Buffer: bytesEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n};\n\nclass DagJsonTokenizer extends cborgJson__namespace.Tokenizer {\n  constructor(data, options) {\n    super(data, options);\n    this.tokenBuffer = [];\n  }\n\n  done() {\n    return this.tokenBuffer.length === 0 && super.done();\n  }\n\n  _next() {\n    if (this.tokenBuffer.length > 0) {\n      return this.tokenBuffer.pop();\n    }\n\n    return super.next();\n  }\n\n  next() {\n    const token = this._next();\n\n    if (token.type === cborg.Type.map) {\n      const keyToken = this._next();\n\n      if (keyToken.type === cborg.Type.string && keyToken.value === '/') {\n        const valueToken = this._next();\n\n        if (valueToken.type === cborg.Type.string) {\n          const breakToken = this._next();\n\n          if (breakToken.type !== cborg.Type.break) {\n            throw new Error('Invalid encoded CID form');\n          }\n\n          this.tokenBuffer.push(valueToken);\n          return new cborg.Token(cborg.Type.tag, 42, 0);\n        }\n\n        if (valueToken.type === cborg.Type.map) {\n          const innerKeyToken = this._next();\n\n          if (innerKeyToken.type === cborg.Type.string && innerKeyToken.value === 'bytes') {\n            const innerValueToken = this._next();\n\n            if (innerValueToken.type === cborg.Type.string) {\n              for (let i = 0; i < 2; i++) {\n                const breakToken = this._next();\n\n                if (breakToken.type !== cborg.Type.break) {\n                  throw new Error('Invalid encoded Bytes form');\n                }\n              }\n\n              const bytes = base64.base64.decode(\"m\".concat(innerValueToken.value));\n              return new cborg.Token(cborg.Type.bytes, bytes, innerValueToken.value.length);\n            }\n\n            this.tokenBuffer.push(innerValueToken);\n          }\n\n          this.tokenBuffer.push(innerKeyToken);\n        }\n\n        this.tokenBuffer.push(valueToken);\n      }\n\n      this.tokenBuffer.push(keyToken);\n    }\n\n    return token;\n  }\n\n}\n\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true,\n  strict: true,\n  useMaps: false,\n  tags: []\n};\ndecodeOptions.tags[42] = multiformats.CID.parse;\nconst name = 'dag-json';\nconst code = 297;\n\nconst encode = node => cborgJson__namespace.encode(node, encodeOptions);\n\nconst decode = data => {\n  const options = Object.assign(decodeOptions, {\n    tokenizer: new DagJsonTokenizer(data, decodeOptions)\n  });\n  return cborgJson__namespace.decode(data, options);\n};\n\nexports.code = code;\nexports.decode = decode;\nexports.encode = encode;\nexports.name = name;","map":null,"metadata":{},"sourceType":"script"}