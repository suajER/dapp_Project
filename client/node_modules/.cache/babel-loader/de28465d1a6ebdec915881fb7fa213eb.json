{"ast":null,"code":"import _slicedToArray from \"D:\\\\test\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport * as React from 'react';\nimport ReactDOM from 'react-dom';\nimport useCallbackRef from '@restart/hooks/useCallbackRef';\nimport useMergedRefs from '@restart/hooks/useMergedRefs';\nimport { useState } from 'react';\nimport usePopper from './usePopper';\nimport useRootClose from './useRootClose';\nimport useWaitForDOMRef from './useWaitForDOMRef';\nimport mergeOptionsWithPopperConfig from './mergeOptionsWithPopperConfig';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n/**\n * Built on top of `Popper.js`, the overlay component is\n * great for custom tooltip overlays.\n */\n\nconst Overlay =\n/*#__PURE__*/\nReact.forwardRef((props, outerRef) => {\n  const flip = props.flip,\n        offset = props.offset,\n        placement = props.placement,\n        containerPadding = props.containerPadding,\n        _props$popperConfig = props.popperConfig,\n        popperConfig = _props$popperConfig === void 0 ? {} : _props$popperConfig,\n        Transition = props.transition;\n\n  const _useCallbackRef = useCallbackRef(),\n        _useCallbackRef2 = _slicedToArray(_useCallbackRef, 2),\n        rootElement = _useCallbackRef2[0],\n        attachRef = _useCallbackRef2[1];\n\n  const _useCallbackRef3 = useCallbackRef(),\n        _useCallbackRef4 = _slicedToArray(_useCallbackRef3, 2),\n        arrowElement = _useCallbackRef4[0],\n        attachArrowRef = _useCallbackRef4[1];\n\n  const mergedRef = useMergedRefs(attachRef, outerRef);\n  const container = useWaitForDOMRef(props.container);\n  const target = useWaitForDOMRef(props.target);\n\n  const _useState = useState(!props.show),\n        _useState2 = _slicedToArray(_useState, 2),\n        exited = _useState2[0],\n        setExited = _useState2[1];\n\n  const popper = usePopper(target, rootElement, mergeOptionsWithPopperConfig({\n    placement,\n    enableEvents: !!props.show,\n    containerPadding: containerPadding || 5,\n    flip,\n    offset,\n    arrowElement,\n    popperConfig\n  }));\n\n  if (props.show) {\n    if (exited) setExited(false);\n  } else if (!props.transition && !exited) {\n    setExited(true);\n  }\n\n  const handleHidden = (...args) => {\n    setExited(true);\n\n    if (props.onExited) {\n      props.onExited(...args);\n    }\n  }; // Don't un-render the overlay while it's transitioning out.\n\n\n  const mountOverlay = props.show || Transition && !exited;\n  useRootClose(rootElement, props.onHide, {\n    disabled: !props.rootClose || props.rootCloseDisabled,\n    clickTrigger: props.rootCloseEvent\n  });\n\n  if (!mountOverlay) {\n    // Don't bother showing anything if we don't have to.\n    return null;\n  }\n\n  let child = props.children(Object.assign({}, popper.attributes.popper, {\n    style: popper.styles.popper,\n    ref: mergedRef\n  }), {\n    popper,\n    placement,\n    show: !!props.show,\n    arrowProps: Object.assign({}, popper.attributes.arrow, {\n      style: popper.styles.arrow,\n      ref: attachArrowRef\n    })\n  });\n\n  if (Transition) {\n    const onExit = props.onExit,\n          onExiting = props.onExiting,\n          onEnter = props.onEnter,\n          onEntering = props.onEntering,\n          onEntered = props.onEntered;\n    child =\n    /*#__PURE__*/\n    _jsx(Transition, {\n      in: props.show,\n      appear: true,\n      onExit: onExit,\n      onExiting: onExiting,\n      onExited: handleHidden,\n      onEnter: onEnter,\n      onEntering: onEntering,\n      onEntered: onEntered,\n      children: child\n    });\n  }\n\n  return container ?\n  /*#__PURE__*/\n  ReactDOM.createPortal(child, container) : null;\n});\nOverlay.displayName = 'Overlay';\nexport default Overlay;","map":null,"metadata":{},"sourceType":"module"}