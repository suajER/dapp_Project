{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar token = require('../token.js');\n\nvar encode$1 = require('../encode.js');\n\nvar common = require('../common.js');\n\nvar byteUtils = require('../byte-utils.js');\n\nclass JSONEncoder extends Array {\n  constructor() {\n    super();\n    this.inRecursive = [];\n  }\n\n  prefix(buf) {\n    const recurs = this.inRecursive[this.inRecursive.length - 1];\n\n    if (recurs) {\n      if (recurs.type === token.Type.array) {\n        recurs.elements++;\n\n        if (recurs.elements !== 1) {\n          buf.push([44]);\n        }\n      }\n\n      if (recurs.type === token.Type.map) {\n        recurs.elements++;\n\n        if (recurs.elements !== 1) {\n          if (recurs.elements % 2 === 1) {\n            buf.push([44]);\n          } else {\n            buf.push([58]);\n          }\n        }\n      }\n    }\n  }\n\n  [token.Type.uint.major](buf, token) {\n    this.prefix(buf);\n    const is = String(token.value);\n    const isa = [];\n\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n    }\n\n    buf.push(isa);\n  }\n\n  [token.Type.negint.major](buf, token$1) {\n    this[token.Type.uint.major](buf, token$1);\n  }\n\n  [token.Type.bytes.major](_buf, _token) {\n    throw new Error(\"\".concat(common.encodeErrPrefix, \" unsupported type: Uint8Array\"));\n  }\n\n  [token.Type.string.major](buf, token) {\n    this.prefix(buf);\n    const byts = byteUtils.fromString(JSON.stringify(token.value));\n    buf.push(byts.length > 32 ? byteUtils.asU8A(byts) : byts);\n  }\n\n  [token.Type.array.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: token.Type.array,\n      elements: 0\n    });\n    buf.push([91]);\n  }\n\n  [token.Type.map.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: token.Type.map,\n      elements: 0\n    });\n    buf.push([123]);\n  }\n\n  [token.Type.tag.major](_buf, _token) {}\n\n  [token.Type.float.major](buf, token$1) {\n    if (token$1.type.name === 'break') {\n      const recurs = this.inRecursive.pop();\n\n      if (recurs) {\n        if (recurs.type === token.Type.array) {\n          buf.push([93]);\n        } else if (recurs.type === token.Type.map) {\n          buf.push([125]);\n        } else {\n          throw new Error('Unexpected recursive type; this should not happen!');\n        }\n\n        return;\n      }\n\n      throw new Error('Unexpected break; this should not happen!');\n    }\n\n    if (token$1.value === undefined) {\n      throw new Error(\"\".concat(common.encodeErrPrefix, \" unsupported type: undefined\"));\n    }\n\n    this.prefix(buf);\n\n    if (token$1.type.name === 'true') {\n      buf.push([116, 114, 117, 101]);\n      return;\n    } else if (token$1.type.name === 'false') {\n      buf.push([102, 97, 108, 115, 101]);\n      return;\n    } else if (token$1.type.name === 'null') {\n      buf.push([110, 117, 108, 108]);\n      return;\n    }\n\n    const is = String(token$1.value);\n    const isa = [];\n    let dp = false;\n\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n\n      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {\n        dp = true;\n      }\n    }\n\n    if (!dp) {\n      isa.push(46);\n      isa.push(48);\n    }\n\n    buf.push(isa);\n  }\n\n}\n\nfunction mapSorter(e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(\"\".concat(common.encodeErrPrefix, \" complex map keys are not supported\"));\n  }\n\n  const keyToken1 = e1[0];\n  const keyToken2 = e2[0];\n\n  if (keyToken1.type !== token.Type.string || keyToken2.type !== token.Type.string) {\n    throw new Error(\"\".concat(common.encodeErrPrefix, \" non-string map keys are not supported\"));\n  }\n\n  if (keyToken1 < keyToken2) {\n    return -1;\n  }\n\n  if (keyToken1 > keyToken2) {\n    return 1;\n  }\n\n  throw new Error(\"\".concat(common.encodeErrPrefix, \" unexpected duplicate map keys, this is not supported\"));\n}\n\nconst defaultEncodeOptions = {\n  addBreakTokens: true,\n  mapSorter\n};\n\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encode$1.encodeCustom(data, new JSONEncoder(), options);\n}\n\nexports.encode = encode;","map":null,"metadata":{},"sourceType":"script"}